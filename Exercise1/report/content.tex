\section*{Exercise 1}

\subsection*{Part A}

PEAS descriptions for a robot basketball player, industrial orange-apple sorter and a stock investor are given in Table \ref{table:peas}.

\input{tables/peas}



\subsection*{Part B}

\textbf{Robot basketball player:} \textit{Simple reflex agents} cannot perform well in this partially observable, dynamic environment. An \textit{internal-state model} could be used, but we would need many states that are difficult to define in such a continuous-state environment. In addition, simply storing the current state of the system would not be enough for the player to decide its next course of action. Furthermore, a \textit{goal-based agent} would be inefficient since scoring is not the only goal in basketball. Therefore, \textit{a utility-based model} is deemed necessary to provide a more efficient performance measure in this multiagent environment. Online \textit{learning} could also be applied during the match, allowing adaptation against the opposing team. Its application however would be difficult without sacrificing (at least their initial) performance.

\textbf{Industrial orange-apple sorter:} An \textit{internal-state model} would be enough for fruit classification based on the partially observable fruits and stochastic background (e.g. varying light in the room or existing branches/leaves). \textit{Learning} would be useful if we wanted our agent to classify more types of fruits in the future.

\textbf{Stock investor:} Similar to a robot basketball player, this agent needs to consider not only its basic goal of maximizing its net profit (namely buying cheaply and selling expensively), but also other features such as credibility, financial forecasts and cooperation with other investors. Therefore, a \textit{utility-based agent} would again be more appropriate. \textit{Learning} could also be proven useful in adaptation against opposing agents and new financial, cultural and political conditions.



\section*{Exercise 2}

\subsection*{Part A}

The solution is given in Figure \ref{fig:exercise2}.

\begin{figure}[htpb]
\centering
\makebox[\textwidth]{%
\includegraphics[width=0.3\textwidth, angle =-90, trim = 25mm 25mm 100mm 25mm,clip=true]{images/exercise2.pdf}}
\caption{State space for states 1 to 15, starting from 1, while the successor function returning two states, $2n$ and $2n+1$.}
\label{fig:exercise2}
% Place the label just after the caption to make the link work
\end{figure} % table makes a floating object with a title

\subsection*{Part B}

The order in which the nodes will be visited for each type of search is given below:

\begin{itemize}

\item Breadth-First Search: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11

\item Depth-Limited Search (depth limit 3): 1, 2, 4, 8, 9, 5, 10, 11

\item Iterative Deepening Search: (depth limit 0) 1 - (depth limit 1) 1, 2, 3 - (depth limit 2) 1, 2, 4, 5, 3, 6, 7 - (depth limit 3) 1, 2, 4, 8, 9, 5, 10, 11

\end{itemize}

\subsection*{Part C}

Bidirectional search would be quite appropriate for this problem, since we could easily employ the inverse of the successor function for searching in the opposite direction (from goal to start state): $\lfloor n/2 \rfloor$. For example, the bidirectional search algorithm would work as follows:

\begin{itemize}

\item Search from start: 1, 2, 3

\item Search from goal: 11, 5, (2)

\end{itemize}

The algorithm would terminate when the search from goal reaches node 2, which would have already been reached by the search from start. The final solution would therefore be 1, 2, 5, 11.

Bidirectional search would actually allow us to avoid searching altogether because each node has only a single predecessor. Hence, the solution could simply be found in $\log_2{n}$ steps.

\section*{Exercise 3}

The solution is given in Figure \ref{fig:exercise3}.

\begin{sidewaysfigure}[htpb]
\centering
\makebox[\textwidth]{%
\includegraphics[width=0.55\textwidth, angle =-90, trim = 25mm 25mm 50mm 25mm,clip=true]{images/exercise3.pdf}}
\caption{Stages in an A* search from Lugoj to Bucharest. Nodes are labeled with $f = g+ h$ (black font), and with the selected order of expansion (red font). Having a sequence of states during each iteration, the algorithm expands the node with the lowest value of $f$, replacing it in the sequence with all its successors (to be considered for the following iteration). The optimal solution is depicted with red nodes and edges.}
\label{fig:exercise3}
% Place the label just after the caption to make the link work
\end{sidewaysfigure} % table makes a floating object with a title


\section*{Exercise 4}

\subsection*{Part A}

Since only one state ($k=1$) is stored in memory after each iteration, it is iteratively succeeded by its best neighboring state like in hill climbing. Hence, the local beam search algorithm with $k=1$ is a simple hill climbing algorithm.

\subsection*{Part B}

With temperature $T=0$, we can say that the probability $e^{\Delta E/T}=0$ when $\Delta E \le 0$, namely only better neighboring solutions are accepted. Therefore, simulated annealing with $T=0$ is a first choice hill climbing algorithm.

\subsection*{Part C}

If $N=1$, the population will consist of a single individual. Crossover will thus happen between (two copies of) that individual, resulting in the exact same solution. The random mutation mechanism will introduce a small number of point changes during each iteration, consequently turning genetic algorithm into a random walk.


%\section{Σκοπός - Υποθέσεις}
%
%Η παρούσα προγραμματιστική άσκηση αποτελεί μία πρώτη πρακτική εξοικείωση των φοιτητών με: 1) την έννοια της χρονικής πολυπλοκότητας, 2) την οργάνωση της πληροφορίας σε σελίδες στον δίσκο, και 3) την απόδοση διαφόρων μεθόδων αναζήτησης σε αυτόν.
%
%Για την ανάπτυξη του παρόντος προγράμματος χρησιμοποιήθηκε η γλώσσα προγραμματισμού \en Java, \gr και το εργαλείο \en Eclipse IDE for Java Developers, Neon Release (4.6.0), \gr στο οποίο μεταφράστηκε και εκτελέστηκε. Πέρα από την \en Java SE 1.8. \gr (και φυσικά το ίδιο το παραδοτέο \en project) \gr δεν απαιτείται η εισαγωγή κάποιας άλλης βιβλιοθήκης.
%
%Η παρούσα εφαρμογή ακολουθεί την εξής λογική: 1) Δημιουργία και αποθήκευση ενός αρχείου που περιέχει ταξινομημένους ακεραίους έως ένα προκαθορισμένο ακέραιο, ξεκινώντας από το ένα και αυξάνοντας κατά ένα. 2) Αναζήτηση κλειδιών (ακεραίων) σε αρχείο που περιέχει ταξινομημένους (με αύξουσα σειρά) ακεραίους με τέσσερις διαφορετικούς τρόπους (σειριακή, απλή δυαδική, δυαδική με ομαδοποίηση ερωτημάτων, δυαδική με χρήση προσωρινής μνήμης. 3) Για την επεξεργασία του αρχείου χρησιμοποιείται δυαδικό \en buffer \gr στη μνήμη, μεγέθους μιας σελίδας δίσκου, ενώ το μέγεθος της σελίδας είναι προκαθορισμένο. 4) Κάθε είδος αναζήτησης επαναλαμβάνεται σύμφωνα με έναν ορισμένο αριθμό επαναλήψεων για εξαγωγή της μέσης τιμής προσβάσεων στο δίσκο.
%
%Όσον αφορά τους περιορισμούς σωστής λειτουργίας του προγράμματος: 1) Ο κώδικας υποστηρίζει την εγγραφή και αναζήτηση σε δυαδικό αρχείο οποιουδήποτε συνδυασμού πλήθους ταξινομημένων ακεραίων και μεγέθους σελίδας του δίσκου. Αυτό φυσικά προϋποθέτει να δοθούν σωστά οι παράμετροι μεγέθους σελίδας \textit{(\en bufferSize)} \gr και πλήθους ακεραίων \textit{(\en numberOfInt)} \gr που χρησιμοποιήθηκαν κατά την εγγραφή του αρχείου. 2) Επιπλέον, οι ακέραιοι της εφαρμογής περιορίζονται από το \en primitive type  \textit{int} \gr της \en Java, \gr δηλαδή είναι \en 32-bit signed two's-complement. \gr Έτσι μεγαλύτεροι ακέραιοι δεν υποστηρίζονται.
%
%
%\section{Υλοποίηση}
%
%Το κύριο μέρος της υλοποίησης του προγράμματος πραγματοποιείται από δύο κλάσεις, την \en FileHandler \gr και την \en MainController. \gr Η πρώτη περιέχει, με ξεχωριστή μέθοδο ανά ερώτημα, τη ζητούμενη λειτουργικότητα, ενώ η δεύτερη περιέχει τη \en main, \gr από όπου και φαίνεται η ροή του συνολικού προγράμματος. Στις επόμενες υποενότητες παραθέτω τη γενική ιδέα επίλυσης κάθε ερωτήματος ξεχωριστά.
%
%Πέραν τούτων, χρησιμοποιήθηκαν άλλες τέσσερις βοηθητικές κλάσεις και μία διεπαφή \en (interface). \gr Πιο συγκεκριμένα, χρησιμοποίησα τις \en Queue \gr (διεπαφή), \en ArrayQueue, \gr και \en QueueEndReachedException \gr για την υλοποίηση της ουράς ως δομή προσωρινής μνήμης, τη \en DiskPage \gr για τη αποθήκευση του \en buffer \gr μαζί με τη σελίδα του αρχείου στην οποία αντιστοιχεί, και την \en Assert \gr για τον έλεγχο \en boolean \gr παραμέτρων (δείτε ενότητα \ref{sec:sources} για τις πηγές και τροποποιήσεις).
%
%
%
%
%\subsection{Εισαγωγή και Ανάγνωση Στοιχείων}
%
%Η δημιουργία του ζητούμενου αρχείου βασίζεται στη μέθοδο \en create. \gr Όλοι οι ακέραιοι εισάγονται αρχικά με αύξουσα σειρά σε ένα \en array, \gr από το οποίο και αντιγράφονται στο \en buffer \gr (και κατ' επέκταση στο αρχείο) ακέραιοι πλήθους μίας σελίδας, έως ότου γραφτούν όλοι οι ακέραιοι με σειριακό τρόπο (σε ένα \en for loop). \gr Για τη λειτουργικότητα \en seek \gr και \en write \gr χρησιμοποιήθηκε η κλάση \en RandomAccessFile, \gr ενώ οι κλάσεις \en ByteBuffer, IntBuffer \gr ανέλαβαν τη μετατροπή του \en int array \gr σε \en byte array. \gr Αντίστροφη διαδικασία χρησιμοποιείται με τη μέθοδο \en readPage \gr σε όλες τις αναζητήσεις για την ανάγνωση του αρχείου, με τη μέθοδο να επιστρέφει ένα αντικείμενο της κλάσης \en DiskPage. \gr
%
%Άξια αναφοράς αποτελεί η προσθήκη του \en Integer.\textit{MAX\_VALUE} (0x7FFFFFFF) \gr σε πιθανές κενές θέσεις της τελευταίας σελίδας του αρχείου. Επέλεξα αυτή τη μέθοδο ώστε το \en buffer \gr της τελευταίας σελίδας να παραμένει σε κάθε περίπτωση ταξινομημένο, εξασφαλίζοντας έτσι τη σωστή λειτουργία της έτοιμης μεθόδου \en Arrays.binarySearch. \gr Φυσικά για την ειδική περίπτωση των τιμών της άσκησης δεν υπάρχουν κενές θέσεις.
%
%
%
%\subsection{Σειριακή Αναζήτηση στο Αρχείο για Τυχαίο Κλειδί}
%\label{sequential}
%
%Για την σειριακή αναζήτηση αρκεί η χρήση ενός \en for loop, \gr το οποίο αντιστοιχεί στον αριθμό των ερωτημάτων, και ενός φωλιασμένου \en do while, \gr για την σειριακή ανάγνωση των σελίδων έως ότου βρει τον ζητούμενο ακέραιο ή αποτύχει φτάνοντας στο τέλος του αρχείου. Η ανάγνωση των σελιδών γίνεται με τη χρήση ενός \textit{\en filePointer}, \gr που αλλάζει σύμφωνα με τη σχέση \en $\textit{filePointer} = (\textit{currentPage}-1)\cdot\textit{bufferSize}$. \gr Φυσικά, σε κάθε ανάγνωση σελίδας η μεταβλητή-μετρητής \textit{\en diskAccesses} αυξάνεται κατά ένα. 
%
%Για την εξαγωγή τυχαίων κλειδιών (μέσα στο εύρος τιμών του αρχείου), ανέπτυξα τη μέθοδο \en getRandomIntegers, \gr η οποία και κάνει χρήση της κλάσης ψευδοτυχαίων αριθμών \en Random. \gr Τέλος, για την δυαδική αναζήτηση μέσα στο \en buffer, \gr χρησιμοποιήθηκε η μέθοδος \en Arrays.binarySearch. \gr
%
%\subsection{Δυαδική Αναζήτηση στο Αρχείο για Τυχαίο Κλειδί}
%\label{binary}
%
%Η δυαδική αναζήτηση στο αρχείο διαφέρει από τη σειριακή αναζήτηση μόνο στη σειρά διάσχισης των σελίδων του αρχείου. Έτσι ψάχνουμε τον ακέραιο ξεκινώντας από τη μεσαία σελίδα του υπολειπόμενου αρχείου, και ανάλογα με την τιμή που επιστρέφει η μέθοδος \en Arrays.binarySearch \gr (είτε -1 αν είναι σε προηγούμενη σελίδα, είτε -1-πλήθος ακεραίων στο \en buffer \gr αν είναι σε επόμενη σελίδα, ή η θέση στο \en buffer \gr αν βρεθεί) συνεχίζουμε τον έλεγχο στη μεσαία σελίδα του δεξιού ή αριστερού μισού του υπολειπόμενου αρχείου. Η διαδικασία αυτή επαναλαμβάνεται έως ότου μηδενιστεί το εύρος των πιθανών σελίδων ή βρεθεί ο αριθμός.
%
%\subsection{Δυαδική Αναζήτηση με Ομαδοποίηση των Ερωτήσεων}
%\label{batch}
%
%Σε αυτό το ερώτημα στην ουσία έρχεται να προστεθεί η μέθοδος \en Arrays.sort, \gr η οποία ταξινομεί τα κλειδιά κατά αύξουσα σειρά. Στη συνέχεια εκτελούμε δυαδική αναζήτηση (όπως προηγουμένως) για το μικρότερο κλειδί. Έχοντας τώρα προσωρινά αποθηκευμένο στο \en buffer \gr την σελίδα που περιείχε το προηγούμενο κλειδί, ελέγχουμε αν και το επόμενο υπάρχει στο \en buffer, \gr γλυτώνοντας έτσι περιττές προσβάσεις στο δίσκο. Διαφορετικά, συνεχίζουμε κανονικά με δυαδική αναζήτηση.
%
%\subsection{Δυαδική Αναζήτηση με Χρήση Προσωρινής Μνήμης}
%\label{queue}
%
%Η λύση εδώ χρησιμοποιεί και επεκτείνει τη λογική της αναζήτησης πρώτα στην προσωρινή μνήμη, και μόνο αν αυτή αποτύχει, έπειτα στο δίσκο. Έτσι, αξιοποιεί την κυκλική λίστα \en ArrayQueue \gr ως δομή μνήμης που περιέχει τις πιο πρόσφατες σελίδες. Στην πράξη, η \en ArrayQueue \gr συμπληρώνεται με σελίδες κατά τη δυαδική αναζήτηση του πρώτου κλειδιού. Συνεπώς, για τις δυαδικές αναζητήσεις των υπόλοιπων κλειδιών όποια σελίδα υπάρχει ήδη στην \en ArrayQueue, \gr δεν χρειάζεται να ξαναδιαβαστεί από το δίσκο.
%
%\section{Τεκμηρίωση Αποτελεσμάτων}
%
%Τα αποτελέσματα του πίνακα \ref{results} επιβεβαιώνουν τις θεωρητικά υπολογιζόμενες χρονικές πολυπλοκότητες (ως προς τον αριθμό προσβάσεων) της σειριακής και δυαδικής αναζήτησης. Συγκεκριμένα, το αρχείο για τις τιμές της άσκησης αποτελείται από $N = 78125$ σελίδες. Επομένως, η σειριακή αναζήτηση είναι και η πιο αργή αφού παρουσιάζει στη μέση περίπτωση χρονική πολυπλοκότητα $(Ν+1)/2 \in \mathcal{O}(N)$, κάτι που επιβεβαιώνει ο μέσος αριθμός προσβάσεων της δοκιμασίας (με την αναμενόμενη στατιστική διακύμανση). Αντίθετα, η απλή δυαδική αναζήτηση παρουσιάζει πολυπλοκότητα $\mathcal{O}(\log{N})$, δικαιολογώντας τη μεγάλη διαφορά στο μέσο αριθμό προσβάσεων $(\log{78125} \approx 16,253)$.
%
%Όσον αφορά τις τεχνικές ομαδοποίησης και προσωρινής μνήμης, παρατηρούμε ότι αν και δεν διαφέρουν στην τάξη μεγέθους της πολυπλοκότητας δυαδικής αναζήτησης, καταφέρνουν να μειώσουν ουσιαστικά τις σταθερές της. Η ομαδοποίηση ερωτημάτων συντελεί ώστε κλειδιά που βρίσκονται στην ίδια σελίδα με το αμέσως προηγούμενό τους να εντοπίζονται σε σταθερό χρόνο ($\mathcal{O}(1)$).Συνεπώς, όταν αυτό συμβαίνει συχνά, δηλαδή όταν η αναλογία αριθμός σελίδων - αριθμός κλειδιών είναι μικρή, βλέπουμε ότι αυτή η μέθοδος πλεονεκτεί (χρονικά). Από την άλλη πλευρά, παρατηρούμε ότι η χρήση προσωρινής μνήμης αποτελεί μία εύρωστη τεχνική, καθώς η απόδοσή της δεν επηρεάζεται από αυτή την αναλογία. Αναμενόμενα, όσο μεγαλύτερη μνήμη χρησιμοποιεί η μέθοδος, τόσο λιγότερες προσβάσεις δίσκου θα χρειαστεί, ενώ για $K = 1$ είναι προφανές ότι θα βοηθήσει μόνο τις ελάχιστες φορές που το κλειδί που αναζητείται βρίσκεται στη μεσαία σελίδα.
%
%Τέλος, σχετικά με την εναλλακτική υλοποίηση της μνήμης, μια απλή και αποτελεσματική λύση θα ήταν η χρήση δομής \en min binary heap, \gr με κλειδί την πιθανότητα χρήσης κάθε σελίδας (συνοδευόμενο από ένα \en hash table \gr ώστε να γνωρίζουμε σε σταθερό χρόνο το που βρίσκεται μέσα στη δομή η κάθε σελίδα). \gr Στην συγκεκριμένη περίπτωση αναμένουμε βελτίωση στο μέσο αριθμό προσβάσεων σε σύγκριση με τα αποτελέσματα της κυκλική ουράς, καθώς οι σελίδες δεν έχουν ίση πιθανότητα χρήσης $p_i$, αλλά αυτή εξαρτάται από το βάθος που βρίσκεται η σελίδα στο αντίστοιχο της αναζήτησης δυαδικό δένδρο \en(BST), \gr δηλαδή $p_i = \fraq{1}/{2^{d_i}}$ (π.χ. η μεσαία σελίδα χρειάζεται πάντα, η μεσαία του δεξιού/αριστερού μισού έχει $p_i =$ 0,5, κ.ο.κ.). Επομένως, ακόμη και αν δεν προ-αποθηκευτούν οι θεωρητικά συχνότερα χρησιμοποιούμενες σελίδες, αναμένουμε σε εύλογο διάστημα χρήσης η κατανομή αυτή να προσεγγιστεί και οι αριθμοί πρόσβασης στο δίσκο να μειωθούν.
%
%\gr
%\begin{table}
%\centering
%\makebox{
%\resizebox{!}{1cm}{\begin{tabular}{c c c c c c c}
%\hline
%\textbf{Μέθοδος} & \textbf{\ref{sequential}} & \textbf{\ref{binary}} & \textbf{\ref{batch}} & \textbf{\ref{queue} ($Κ=1$)} & \textbf{\ref{queue} ($Κ=50$)} & \textbf{\ref{queue} ($Κ=100$)}\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^4$)} & 39000,3 & 15,341 & 14,451 & 15,322 & 12,913 & 11,902\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^5$)} & - & 15,331 & 8,641 & 15,327 & 12,917 & 11,882\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^3$)} & - & 15,41 & 15,28 & 15,353 & 12,928 & 11,931\\
%\hline
%\end{tabular}}
%}
%\caption{Πίνακας μέσου αριθμού προσβάσεων στο δίσκο για $Μ$ αναζητήσεις κάθε μεθόδου.}
%\label{results}
%\end{table}
%\gr
%
%\section{Πηγές και Συνεργασίες}
%\label{sec:sources}
%
%Για την υλοποίηση του προγράμματος υιοθετήθηκαν οι εξής ενδεικτικοί κώδικες του μαθήματος: 1) της διεπαφής \en Queue, \gr και της αντίστοιχης κλάσης \en AQueue, \gr στην οποία και πρόσθεσα μεθόδους για τη σειριακή διάσχιση όλων των στοιχείων της ουράς, φτιάχνοντας έτσι την κλάση \en ArrayQueue \gr και το \en Exception QueueEndReachedException \gr του παραδοτέου. 2) Επιπλέον για λόγους ευκολίας χρησιμοποίησα και την \en Assert. \gr
%
%Κατά τη διεκπεραίωση της άσκησης συνεργάστηκα με τον συμφοιτητή μου Πανταζή Θεόδωρο (ΑΜ 2005030004), τον οποίο και βοήθησα εξηγώντας του τα ζητούμενα της άσκησης, το γενικό τρόπο αντιμετώπισης τέτοιων ασκήσεων, και βασικά τμήματα του κώδικά μου.






