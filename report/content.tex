\section*{Exercise 3}


\section*{Exercise 4}

\subsection*{Part A}

Since only one state ($k=1$) is stored in memory after each iteration, it is iteratively succeeded by its best neighboring state like in hill climbing. Hence, the local beam search algorithm with $k=1$ is a simple hill climbing algorithm.

\subsection*{Part B}

With temperature $T=0$, we can say that the probability $e^{\Delta E/T}=0$ when $\Delta E \le 0$, namely only better neighboring solutions are accepted. Therefore, simulated annealing with $T=0$ is a first choice hill climbing algorithm.

\subsection*{Part C}

If $N=1$, the population will consist of a single individual. Crossover will thus happen between (two copies of) that individual, resulting in the exact same solution. The random mutation mechanism will introduce a small number of point changes during each iteration, consequently turning genetic algorithm into a random walk.


%\section{Σκοπός - Υποθέσεις}
%
%Η παρούσα προγραμματιστική άσκηση αποτελεί μία πρώτη πρακτική εξοικείωση των φοιτητών με: 1) την έννοια της χρονικής πολυπλοκότητας, 2) την οργάνωση της πληροφορίας σε σελίδες στον δίσκο, και 3) την απόδοση διαφόρων μεθόδων αναζήτησης σε αυτόν.
%
%Για την ανάπτυξη του παρόντος προγράμματος χρησιμοποιήθηκε η γλώσσα προγραμματισμού \en Java, \gr και το εργαλείο \en Eclipse IDE for Java Developers, Neon Release (4.6.0), \gr στο οποίο μεταφράστηκε και εκτελέστηκε. Πέρα από την \en Java SE 1.8. \gr (και φυσικά το ίδιο το παραδοτέο \en project) \gr δεν απαιτείται η εισαγωγή κάποιας άλλης βιβλιοθήκης.
%
%Η παρούσα εφαρμογή ακολουθεί την εξής λογική: 1) Δημιουργία και αποθήκευση ενός αρχείου που περιέχει ταξινομημένους ακεραίους έως ένα προκαθορισμένο ακέραιο, ξεκινώντας από το ένα και αυξάνοντας κατά ένα. 2) Αναζήτηση κλειδιών (ακεραίων) σε αρχείο που περιέχει ταξινομημένους (με αύξουσα σειρά) ακεραίους με τέσσερις διαφορετικούς τρόπους (σειριακή, απλή δυαδική, δυαδική με ομαδοποίηση ερωτημάτων, δυαδική με χρήση προσωρινής μνήμης. 3) Για την επεξεργασία του αρχείου χρησιμοποιείται δυαδικό \en buffer \gr στη μνήμη, μεγέθους μιας σελίδας δίσκου, ενώ το μέγεθος της σελίδας είναι προκαθορισμένο. 4) Κάθε είδος αναζήτησης επαναλαμβάνεται σύμφωνα με έναν ορισμένο αριθμό επαναλήψεων για εξαγωγή της μέσης τιμής προσβάσεων στο δίσκο.
%
%Όσον αφορά τους περιορισμούς σωστής λειτουργίας του προγράμματος: 1) Ο κώδικας υποστηρίζει την εγγραφή και αναζήτηση σε δυαδικό αρχείο οποιουδήποτε συνδυασμού πλήθους ταξινομημένων ακεραίων και μεγέθους σελίδας του δίσκου. Αυτό φυσικά προϋποθέτει να δοθούν σωστά οι παράμετροι μεγέθους σελίδας \textit{(\en bufferSize)} \gr και πλήθους ακεραίων \textit{(\en numberOfInt)} \gr που χρησιμοποιήθηκαν κατά την εγγραφή του αρχείου. 2) Επιπλέον, οι ακέραιοι της εφαρμογής περιορίζονται από το \en primitive type  \textit{int} \gr της \en Java, \gr δηλαδή είναι \en 32-bit signed two's-complement. \gr Έτσι μεγαλύτεροι ακέραιοι δεν υποστηρίζονται.
%
%
%\section{Υλοποίηση}
%
%Το κύριο μέρος της υλοποίησης του προγράμματος πραγματοποιείται από δύο κλάσεις, την \en FileHandler \gr και την \en MainController. \gr Η πρώτη περιέχει, με ξεχωριστή μέθοδο ανά ερώτημα, τη ζητούμενη λειτουργικότητα, ενώ η δεύτερη περιέχει τη \en main, \gr από όπου και φαίνεται η ροή του συνολικού προγράμματος. Στις επόμενες υποενότητες παραθέτω τη γενική ιδέα επίλυσης κάθε ερωτήματος ξεχωριστά.
%
%Πέραν τούτων, χρησιμοποιήθηκαν άλλες τέσσερις βοηθητικές κλάσεις και μία διεπαφή \en (interface). \gr Πιο συγκεκριμένα, χρησιμοποίησα τις \en Queue \gr (διεπαφή), \en ArrayQueue, \gr και \en QueueEndReachedException \gr για την υλοποίηση της ουράς ως δομή προσωρινής μνήμης, τη \en DiskPage \gr για τη αποθήκευση του \en buffer \gr μαζί με τη σελίδα του αρχείου στην οποία αντιστοιχεί, και την \en Assert \gr για τον έλεγχο \en boolean \gr παραμέτρων (δείτε ενότητα \ref{sec:sources} για τις πηγές και τροποποιήσεις).
%
%
%
%
%\subsection{Εισαγωγή και Ανάγνωση Στοιχείων}
%
%Η δημιουργία του ζητούμενου αρχείου βασίζεται στη μέθοδο \en create. \gr Όλοι οι ακέραιοι εισάγονται αρχικά με αύξουσα σειρά σε ένα \en array, \gr από το οποίο και αντιγράφονται στο \en buffer \gr (και κατ' επέκταση στο αρχείο) ακέραιοι πλήθους μίας σελίδας, έως ότου γραφτούν όλοι οι ακέραιοι με σειριακό τρόπο (σε ένα \en for loop). \gr Για τη λειτουργικότητα \en seek \gr και \en write \gr χρησιμοποιήθηκε η κλάση \en RandomAccessFile, \gr ενώ οι κλάσεις \en ByteBuffer, IntBuffer \gr ανέλαβαν τη μετατροπή του \en int array \gr σε \en byte array. \gr Αντίστροφη διαδικασία χρησιμοποιείται με τη μέθοδο \en readPage \gr σε όλες τις αναζητήσεις για την ανάγνωση του αρχείου, με τη μέθοδο να επιστρέφει ένα αντικείμενο της κλάσης \en DiskPage. \gr
%
%Άξια αναφοράς αποτελεί η προσθήκη του \en Integer.\textit{MAX\_VALUE} (0x7FFFFFFF) \gr σε πιθανές κενές θέσεις της τελευταίας σελίδας του αρχείου. Επέλεξα αυτή τη μέθοδο ώστε το \en buffer \gr της τελευταίας σελίδας να παραμένει σε κάθε περίπτωση ταξινομημένο, εξασφαλίζοντας έτσι τη σωστή λειτουργία της έτοιμης μεθόδου \en Arrays.binarySearch. \gr Φυσικά για την ειδική περίπτωση των τιμών της άσκησης δεν υπάρχουν κενές θέσεις.
%
%
%
%\subsection{Σειριακή Αναζήτηση στο Αρχείο για Τυχαίο Κλειδί}
%\label{sequential}
%
%Για την σειριακή αναζήτηση αρκεί η χρήση ενός \en for loop, \gr το οποίο αντιστοιχεί στον αριθμό των ερωτημάτων, και ενός φωλιασμένου \en do while, \gr για την σειριακή ανάγνωση των σελίδων έως ότου βρει τον ζητούμενο ακέραιο ή αποτύχει φτάνοντας στο τέλος του αρχείου. Η ανάγνωση των σελιδών γίνεται με τη χρήση ενός \textit{\en filePointer}, \gr που αλλάζει σύμφωνα με τη σχέση \en $\textit{filePointer} = (\textit{currentPage}-1)\cdot\textit{bufferSize}$. \gr Φυσικά, σε κάθε ανάγνωση σελίδας η μεταβλητή-μετρητής \textit{\en diskAccesses} αυξάνεται κατά ένα. 
%
%Για την εξαγωγή τυχαίων κλειδιών (μέσα στο εύρος τιμών του αρχείου), ανέπτυξα τη μέθοδο \en getRandomIntegers, \gr η οποία και κάνει χρήση της κλάσης ψευδοτυχαίων αριθμών \en Random. \gr Τέλος, για την δυαδική αναζήτηση μέσα στο \en buffer, \gr χρησιμοποιήθηκε η μέθοδος \en Arrays.binarySearch. \gr
%
%\subsection{Δυαδική Αναζήτηση στο Αρχείο για Τυχαίο Κλειδί}
%\label{binary}
%
%Η δυαδική αναζήτηση στο αρχείο διαφέρει από τη σειριακή αναζήτηση μόνο στη σειρά διάσχισης των σελίδων του αρχείου. Έτσι ψάχνουμε τον ακέραιο ξεκινώντας από τη μεσαία σελίδα του υπολειπόμενου αρχείου, και ανάλογα με την τιμή που επιστρέφει η μέθοδος \en Arrays.binarySearch \gr (είτε -1 αν είναι σε προηγούμενη σελίδα, είτε -1-πλήθος ακεραίων στο \en buffer \gr αν είναι σε επόμενη σελίδα, ή η θέση στο \en buffer \gr αν βρεθεί) συνεχίζουμε τον έλεγχο στη μεσαία σελίδα του δεξιού ή αριστερού μισού του υπολειπόμενου αρχείου. Η διαδικασία αυτή επαναλαμβάνεται έως ότου μηδενιστεί το εύρος των πιθανών σελίδων ή βρεθεί ο αριθμός.
%
%\subsection{Δυαδική Αναζήτηση με Ομαδοποίηση των Ερωτήσεων}
%\label{batch}
%
%Σε αυτό το ερώτημα στην ουσία έρχεται να προστεθεί η μέθοδος \en Arrays.sort, \gr η οποία ταξινομεί τα κλειδιά κατά αύξουσα σειρά. Στη συνέχεια εκτελούμε δυαδική αναζήτηση (όπως προηγουμένως) για το μικρότερο κλειδί. Έχοντας τώρα προσωρινά αποθηκευμένο στο \en buffer \gr την σελίδα που περιείχε το προηγούμενο κλειδί, ελέγχουμε αν και το επόμενο υπάρχει στο \en buffer, \gr γλυτώνοντας έτσι περιττές προσβάσεις στο δίσκο. Διαφορετικά, συνεχίζουμε κανονικά με δυαδική αναζήτηση.
%
%\subsection{Δυαδική Αναζήτηση με Χρήση Προσωρινής Μνήμης}
%\label{queue}
%
%Η λύση εδώ χρησιμοποιεί και επεκτείνει τη λογική της αναζήτησης πρώτα στην προσωρινή μνήμη, και μόνο αν αυτή αποτύχει, έπειτα στο δίσκο. Έτσι, αξιοποιεί την κυκλική λίστα \en ArrayQueue \gr ως δομή μνήμης που περιέχει τις πιο πρόσφατες σελίδες. Στην πράξη, η \en ArrayQueue \gr συμπληρώνεται με σελίδες κατά τη δυαδική αναζήτηση του πρώτου κλειδιού. Συνεπώς, για τις δυαδικές αναζητήσεις των υπόλοιπων κλειδιών όποια σελίδα υπάρχει ήδη στην \en ArrayQueue, \gr δεν χρειάζεται να ξαναδιαβαστεί από το δίσκο.
%
%\section{Τεκμηρίωση Αποτελεσμάτων}
%
%Τα αποτελέσματα του πίνακα \ref{results} επιβεβαιώνουν τις θεωρητικά υπολογιζόμενες χρονικές πολυπλοκότητες (ως προς τον αριθμό προσβάσεων) της σειριακής και δυαδικής αναζήτησης. Συγκεκριμένα, το αρχείο για τις τιμές της άσκησης αποτελείται από $N = 78125$ σελίδες. Επομένως, η σειριακή αναζήτηση είναι και η πιο αργή αφού παρουσιάζει στη μέση περίπτωση χρονική πολυπλοκότητα $(Ν+1)/2 \in \mathcal{O}(N)$, κάτι που επιβεβαιώνει ο μέσος αριθμός προσβάσεων της δοκιμασίας (με την αναμενόμενη στατιστική διακύμανση). Αντίθετα, η απλή δυαδική αναζήτηση παρουσιάζει πολυπλοκότητα $\mathcal{O}(\log{N})$, δικαιολογώντας τη μεγάλη διαφορά στο μέσο αριθμό προσβάσεων $(\log{78125} \approx 16,253)$.
%
%Όσον αφορά τις τεχνικές ομαδοποίησης και προσωρινής μνήμης, παρατηρούμε ότι αν και δεν διαφέρουν στην τάξη μεγέθους της πολυπλοκότητας δυαδικής αναζήτησης, καταφέρνουν να μειώσουν ουσιαστικά τις σταθερές της. Η ομαδοποίηση ερωτημάτων συντελεί ώστε κλειδιά που βρίσκονται στην ίδια σελίδα με το αμέσως προηγούμενό τους να εντοπίζονται σε σταθερό χρόνο ($\mathcal{O}(1)$).Συνεπώς, όταν αυτό συμβαίνει συχνά, δηλαδή όταν η αναλογία αριθμός σελίδων - αριθμός κλειδιών είναι μικρή, βλέπουμε ότι αυτή η μέθοδος πλεονεκτεί (χρονικά). Από την άλλη πλευρά, παρατηρούμε ότι η χρήση προσωρινής μνήμης αποτελεί μία εύρωστη τεχνική, καθώς η απόδοσή της δεν επηρεάζεται από αυτή την αναλογία. Αναμενόμενα, όσο μεγαλύτερη μνήμη χρησιμοποιεί η μέθοδος, τόσο λιγότερες προσβάσεις δίσκου θα χρειαστεί, ενώ για $K = 1$ είναι προφανές ότι θα βοηθήσει μόνο τις ελάχιστες φορές που το κλειδί που αναζητείται βρίσκεται στη μεσαία σελίδα.
%
%Τέλος, σχετικά με την εναλλακτική υλοποίηση της μνήμης, μια απλή και αποτελεσματική λύση θα ήταν η χρήση δομής \en min binary heap, \gr με κλειδί την πιθανότητα χρήσης κάθε σελίδας (συνοδευόμενο από ένα \en hash table \gr ώστε να γνωρίζουμε σε σταθερό χρόνο το που βρίσκεται μέσα στη δομή η κάθε σελίδα). \gr Στην συγκεκριμένη περίπτωση αναμένουμε βελτίωση στο μέσο αριθμό προσβάσεων σε σύγκριση με τα αποτελέσματα της κυκλική ουράς, καθώς οι σελίδες δεν έχουν ίση πιθανότητα χρήσης $p_i$, αλλά αυτή εξαρτάται από το βάθος που βρίσκεται η σελίδα στο αντίστοιχο της αναζήτησης δυαδικό δένδρο \en(BST), \gr δηλαδή $p_i = \fraq{1}/{2^{d_i}}$ (π.χ. η μεσαία σελίδα χρειάζεται πάντα, η μεσαία του δεξιού/αριστερού μισού έχει $p_i =$ 0,5, κ.ο.κ.). Επομένως, ακόμη και αν δεν προ-αποθηκευτούν οι θεωρητικά συχνότερα χρησιμοποιούμενες σελίδες, αναμένουμε σε εύλογο διάστημα χρήσης η κατανομή αυτή να προσεγγιστεί και οι αριθμοί πρόσβασης στο δίσκο να μειωθούν.
%
%\gr
%\begin{table}
%\centering
%\makebox{
%\resizebox{!}{1cm}{\begin{tabular}{c c c c c c c}
%\hline
%\textbf{Μέθοδος} & \textbf{\ref{sequential}} & \textbf{\ref{binary}} & \textbf{\ref{batch}} & \textbf{\ref{queue} ($Κ=1$)} & \textbf{\ref{queue} ($Κ=50$)} & \textbf{\ref{queue} ($Κ=100$)}\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^4$)} & 39000,3 & 15,341 & 14,451 & 15,322 & 12,913 & 11,902\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^5$)} & - & 15,331 & 8,641 & 15,327 & 12,917 & 11,882\\
%\hline
%\up \textbf{Απόδοση ($Μ = 10^3$)} & - & 15,41 & 15,28 & 15,353 & 12,928 & 11,931\\
%\hline
%\end{tabular}}
%}
%\caption{Πίνακας μέσου αριθμού προσβάσεων στο δίσκο για $Μ$ αναζητήσεις κάθε μεθόδου.}
%\label{results}
%\end{table}
%\gr
%
%\section{Πηγές και Συνεργασίες}
%\label{sec:sources}
%
%Για την υλοποίηση του προγράμματος υιοθετήθηκαν οι εξής ενδεικτικοί κώδικες του μαθήματος: 1) της διεπαφής \en Queue, \gr και της αντίστοιχης κλάσης \en AQueue, \gr στην οποία και πρόσθεσα μεθόδους για τη σειριακή διάσχιση όλων των στοιχείων της ουράς, φτιάχνοντας έτσι την κλάση \en ArrayQueue \gr και το \en Exception QueueEndReachedException \gr του παραδοτέου. 2) Επιπλέον για λόγους ευκολίας χρησιμοποίησα και την \en Assert. \gr
%
%Κατά τη διεκπεραίωση της άσκησης συνεργάστηκα με τον συμφοιτητή μου Πανταζή Θεόδωρο (ΑΜ 2005030004), τον οποίο και βοήθησα εξηγώντας του τα ζητούμενα της άσκησης, το γενικό τρόπο αντιμετώπισης τέτοιων ασκήσεων, και βασικά τμήματα του κώδικά μου.






